<!DOCTYPE html>
<html>
<head>
    <title>Outer Boundary Generator for Liefergebiete</title>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        #output { width: 100%; height: 300px; margin-top: 20px; }
        button { padding: 10px; margin-top: 20px; margin-right: 10px; }
        .options {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .options label {
            display: block;
            margin-bottom: 8px;
        }
        input[type="number"] {
            width: 80px;
        }
        #log {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 20px;
            font-family: monospace;
            background-color: #f5f5f5;
        }
        #preview {
            height: 400px;
            margin-top: 20px;
            border: 1px solid #ccc;
            background-color: white;
            position: relative;
            overflow: hidden;
        }
        .progress {
            margin-top: 10px;
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #4285F4;
            width: 0%;
            transition: width 0.3s ease;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .path-gebiet {
            fill-opacity: 0.2;
            stroke-width: 2px;
        }
        .path-zone {
            fill-opacity: 0.1;
            stroke-width: 1px;
            stroke-dasharray: 3, 3;
        }
        .note {
            background-color: #e9f7fe;
            border-left: 4px solid #2196F3;
            padding: 12px;
            margin: 20px 0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Outer Boundary Generator for Liefergebiete</h1>
    <p>This tool creates clean outer boundaries for each Liefergebiet and Zone, ensuring all internal areas are absorbed.</p>
    
    <div class="note">
        <strong>How it works:</strong> This tool identifies the outermost points of each delivery area and creates a boundary that encompasses all points, automatically including any "islands" or gaps within the overall boundary.
    </div>
    
    <div class="options">
        <h3>Configuration Options</h3>
        <label>
            <input type="radio" name="boundary-type" value="simple" checked> 
            Simple Boundaries - Basic outer shape (fastest)
        </label>
        <label>
            <input type="radio" name="boundary-type" value="detailed"> 
            Detailed Boundaries - More precise shape (slower)
        </label>
        <label>
            Simplification Level: 
            <input type="number" id="simplify-level" value="0.01" min="0.001" max="0.1" step="0.001">
            <small>(smaller = more detailed, larger = smoother)</small>
        </label>
        <label>
            Buffer Size (km): 
            <input type="number" id="buffer-size" value="0.5" min="0" max="5" step="0.1">
            <small>(extra padding around boundaries)</small>
        </label>
    </div>
    
    <button id="generate">Generate Outer Boundaries</button>
    <button id="preview-btn">Show Preview</button>
    <button id="download" disabled>Download GeoJSON</button>
    
    <div class="progress">
        <div class="progress-bar" id="progress-bar"></div>
    </div>
    
    <div id="log"></div>
    <div id="preview"></div>
    <textarea id="output" readonly></textarea>

    <script>
        // Data structures to hold the data
        let liefergebieteData;
        let zoneInfo;
        let plzToZoneMap;
        let boundaryLayers = null;
        
        // Add log function
        function log(message) {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        // Set progress bar
        function setProgress(percent) {
            document.getElementById('progress-bar').style.width = `${percent}%`;
        }
        
        // Load the required data files
        fetch('data/vorwahlen+plz.json')
            .then(response => response.json())
            .then(data => {
                liefergebieteData = data;
                log("‚úÖ Liefergebiete data loaded");
                checkAllLoaded();
            })
            .catch(error => {
                log("‚ùå Error loading Liefergebiete data: " + error.message);
            });
            
        fetch('data/nos_zones.json')
            .then(response => response.json())
            .then(data => {
                zoneInfo = data;
                log("‚úÖ Zone info loaded");
                checkAllLoaded();
            })
            .catch(error => {
                log("‚ùå Error loading Zone info: " + error.message);
            });
            
        fetch('data/nos_plz_to_zone.json')
            .then(response => response.json())
            .then(data => {
                plzToZoneMap = data;
                log("‚úÖ PLZ to Zone mapping loaded");
                checkAllLoaded();
            })
            .catch(error => {
                log("‚ùå Error loading PLZ to Zone mapping: " + error.message);
            });
        
        function checkAllLoaded() {
            if (liefergebieteData && zoneInfo && plzToZoneMap) {
                document.getElementById('generate').disabled = false;
                document.getElementById('preview-btn').disabled = false;
                log("‚úÖ All data loaded. Ready to generate boundaries");
            }
        }
        
        // Function to determine zone of a feature
        function determineZone(feature) {
            if (!feature || !feature.properties) return null;
            
            let result = null;
            
            // STEP 1: First try direct postal code matching
            if (feature.properties.plz) {
                let plzList = [];
                if (typeof feature.properties.plz === 'object') {
                    plzList = Object.keys(feature.properties.plz);
                } else {
                    plzList = [feature.properties.plz.toString()];
                }

                for (const plz of plzList) {
                    if (plzToZoneMap[plz]) {
                        return plzToZoneMap[plz];
                    }
                }
            }

            // STEP 2: Try using GemKZ
            if (feature.properties.iso) {
                let gemkzList = [];
                if (typeof feature.properties.iso === 'object') {
                    gemkzList = Object.keys(feature.properties.iso);
                } else {
                    gemkzList = [feature.properties.iso.toString()];
                }

                for (const gemkz of gemkzList) {
                    if (gemkz === '60654') return 'F'; // Weinitzen

                    const firstDigit = gemkz.charAt(0);

                    switch(firstDigit) {
                        case '1': result = 'A'; break;
                        case '2': result = 'G'; break;
                        case '3': result = 'B'; break;
                        case '4': result = 'D'; break;
                        case '5': result = 'H'; break;
                        case '6': result = 'F'; break;
                        case '7': result = 'I'; break;
                        case '8': result = 'J'; break;
                        case '9': result = 'A'; break;
                    }

                    if (result) return result;
                }
            }

            // STEP 3: Try vorwahl
            if (feature.properties.vorwahl) {
                let vorwahlList = [];
                if (typeof feature.properties.vorwahl === 'object') {
                    vorwahlList = Object.keys(feature.properties.vorwahl);
                } else {
                    vorwahlList = [feature.properties.vorwahl.toString()];
                }

                for (const vorwahl of vorwahlList) {
                    if (vorwahl.startsWith('1')) return 'A';
                    if (vorwahl.startsWith('2')) return 'A';
                    if (vorwahl.startsWith('3')) return 'B';
                    if (vorwahl.startsWith('4')) return 'D';
                    if (vorwahl.startsWith('5')) return 'H';
                    if (vorwahl.startsWith('6')) return 'G';
                    if (vorwahl.startsWith('7')) return 'A';
                    if (vorwahl.startsWith('8')) return 'F';
                    if (vorwahl.startsWith('9')) return 'G';
                }
            }
            return result;
        }
        
        // Simple SVG preview
        document.getElementById('preview-btn').addEventListener('click', function() {
            if (!boundaryLayers) {
                log("‚ö†Ô∏è No boundaries to preview yet. Please generate boundaries first.");
                return;
            }
            
            renderSimplePreview();
        });
        
        function renderSimplePreview() {
            const previewDiv = document.getElementById('preview');
            previewDiv.innerHTML = '';
            
            // Create SVG element
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            previewDiv.appendChild(svg);
            
            // Get bounds of all features
            let bounds = {
                minX: Infinity,
                minY: Infinity,
                maxX: -Infinity,
                maxY: -Infinity
            };
            
            // Process gebiet boundaries to find bounds
            boundaryLayers.gebietBoundaries.features.forEach(feature => {
                if (feature.geometry && feature.geometry.coordinates) {
                    turf.coordAll(feature).forEach(coord => {
                        bounds.minX = Math.min(bounds.minX, coord[0]);
                        bounds.minY = Math.min(bounds.minY, coord[1]);
                        bounds.maxX = Math.max(bounds.maxX, coord[0]);
                        bounds.maxY = Math.max(bounds.maxY, coord[1]);
                    });
                }
            });
            
            // Set up SVG viewport
            const svgWidth = previewDiv.clientWidth;
            const svgHeight = previewDiv.clientHeight;
            const padding = 20;
            
            // Function to convert geo coordinates to SVG coordinates
            function geoToSvg(coord) {
                const normalizedX = (coord[0] - bounds.minX) / (bounds.maxX - bounds.minX);
                const normalizedY = 1 - (coord[1] - bounds.minY) / (bounds.maxY - bounds.minY); // Invert Y for SVG
                
                return {
                    x: padding + normalizedX * (svgWidth - 2 * padding),
                    y: padding + normalizedY * (svgHeight - 2 * padding)
                };
            }
            
            // Function to create SVG path from geometry
            function geometryToPath(geometry) {
                let pathData = '';
                
                if (geometry.type === 'Polygon') {
                    geometry.coordinates.forEach(ring => {
                        // Start path
                        if (ring.length > 0) {
                            const start = geoToSvg(ring[0]);
                            pathData += `M ${start.x} ${start.y} `;
                            
                            // Add line segments
                            for (let i = 1; i < ring.length; i++) {
                                const point = geoToSvg(ring[i]);
                                pathData += `L ${point.x} ${point.y} `;
                            }
                            
                            // Close path
                            pathData += 'Z ';
                        }
                    });
                } else if (geometry.type === 'MultiPolygon') {
                    geometry.coordinates.forEach(polygon => {
                        polygon.forEach(ring => {
                            // Start path
                            if (ring.length > 0) {
                                const start = geoToSvg(ring[0]);
                                pathData += `M ${start.x} ${start.y} `;
                                
                                // Add line segments
                                for (let i = 1; i < ring.length; i++) {
                                    const point = geoToSvg(ring[i]);
                                    pathData += `L ${point.x} ${point.y} `;
                                }
                                
                                // Close path
                                pathData += 'Z ';
                            }
                        });
                    });
                }
                
                return pathData;
            }
            
            // Draw gebiet boundaries
            boundaryLayers.gebietBoundaries.features.forEach(feature => {
                if (feature.geometry) {
                    const pathData = geometryToPath(feature.geometry);
                    const gebiet = feature.properties.gebiet;
                    const color = zoneInfo.gebiet[gebiet]?.color || '#CCCCCC';
                    
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute('d', pathData);
                    path.setAttribute('fill', color);
                    path.setAttribute('stroke', '#FF0000');
                    path.setAttribute('class', 'path-gebiet');
                    path.setAttribute('title', `Liefergebiet ${gebiet}: ${feature.properties.name}`);
                    
                    svg.appendChild(path);
                }
            });
            
            // Draw zone boundaries on top with dashed lines
            boundaryLayers.zoneBoundaries.features.forEach(feature => {
                if (feature.geometry) {
                    const pathData = geometryToPath(feature.geometry);
                    const zone = feature.properties.zone;
                    const color = zoneInfo.zones[zone]?.color || '#CCCCCC';
                    
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute('d', pathData);
                    path.setAttribute('fill', color);
                    path.setAttribute('stroke', '#000000');
                    path.setAttribute('class', 'path-zone');
                    path.setAttribute('title', `Zone ${zone}: ${feature.properties.name}`);
                    
                    svg.appendChild(path);
                }
            });
            
            log("üìä Simple preview rendered");
        }
        
        // Generate outer boundaries
        document.getElementById('generate').addEventListener('click', async function() {
            log("üîÑ Starting boundary generation...");
            document.getElementById('generate').disabled = true;
            document.getElementById('download').disabled = true;
            setProgress(0);
            
            // Get configuration options
            const boundaryType = document.querySelector('input[name="boundary-type"]:checked').value;
            const simplifyLevel = parseFloat(document.getElementById('simplify-level').value);
            const bufferSize = parseFloat(document.getElementById('buffer-size').value);
            
            log(`üìê Configuration: ${boundaryType} boundaries, simplify=${simplifyLevel}, buffer=${bufferSize}km`);
            
            try {
                // Group features by their delivery area (gebiet) and zone
                const gebietFeatures = {};
                const zoneFeatures = {};
                
                // Process all features
                log("üìä Analyzing features...");
                let processedCount = 0;
                const totalFeatures = liefergebieteData.features.length;
                
                for (const feature of liefergebieteData.features) {
                    const zone = determineZone(feature);
                    if (!zone) {
                        processedCount++;
                        continue;
                    }
                    
                    // Group by gebiet
                    const gebiet = zoneInfo.zones[zone]?.gebiet;
                    if (gebiet) {
                        if (!gebietFeatures[gebiet]) {
                            gebietFeatures[gebiet] = [];
                        }
                        gebietFeatures[gebiet].push(feature);
                    }
                    
                    // Group by zone
                    if (!zoneFeatures[zone]) {
                        zoneFeatures[zone] = [];
                    }
                    zoneFeatures[zone].push(feature);
                    
                    // Update progress
                    processedCount++;
                    if (processedCount % 100 === 0 || processedCount === totalFeatures) {
                        setProgress((processedCount / totalFeatures) * 30); // First 30% is analysis
                    }
                }
                
                log("üî® Creating outer boundaries...");
                
                // Create outer boundaries for each gebiet
                const gebietBoundaries = {
                    type: 'FeatureCollection',
                    features: []
                };
                
                let processedGebiete = 0;
                const totalGebiete = Object.keys(gebietFeatures).length;
                
                for (const gebiet in gebietFeatures) {
                    log(`üèóÔ∏è Processing Liefergebiet ${gebiet}...`);
                    
                    try {
                        // Extract all points from all features in this gebiet
                        let allCoordinates = [];
                        gebietFeatures[gebiet].forEach(feature => {
                            const coords = turf.coordAll(feature);
                            allCoordinates = allCoordinates.concat(coords);
                        });
                        
                        if (allCoordinates.length < 3) {
                            log(`‚ö†Ô∏è Not enough coordinates for Liefergebiet ${gebiet}, skipping`);
                            continue;
                        }
                        
                        // Create a points feature collection
                        const points = turf.points(allCoordinates);
                        
                        // Create an outer boundary based on the selected method
                        let boundary;
                        
                        if (boundaryType === 'simple') {
                            // Simple boundary - create convex hull
                            boundary = turf.convex(points);
                        } else {
                            // Detailed boundary - create concave hull with a large value to allow concavities
                            boundary = turf.concave(points, { maxEdge: 20, units: 'kilometers' });
                            if (!boundary) {
                                // Fall back to convex hull if concave fails
                                boundary = turf.convex(points);
                            }
                        }
                        
                        // Simplify the boundary to reduce complexity
                        const simplified = turf.simplify(boundary, {
                            tolerance: simplifyLevel,
                            highQuality: true
                        });
                        
                        // Add buffer if specified
                        let finalBoundary = simplified;
                        if (bufferSize > 0) {
                            finalBoundary = turf.buffer(simplified, bufferSize, { units: 'kilometers' });
                        }
                        
                        // Add the boundary to the collection
                        gebietBoundaries.features.push({
                            type: 'Feature',
                            properties: {
                                gebiet: gebiet,
                                name: zoneInfo.gebiet[gebiet].name,
                                color: zoneInfo.gebiet[gebiet].color
                            },
                            geometry: finalBoundary.geometry
                        });
                    } catch (error) {
                        log(`‚ö†Ô∏è Error processing Liefergebiet ${gebiet}: ${error.message}`);
                    }
                    
                    // Update progress
                    processedGebiete++;
                    setProgress(30 + (processedGebiete / totalGebiete) * 35); // 30-65%
                }
                
                // Create outer boundaries for each zone
                const zoneBoundaries = {
                    type: 'FeatureCollection',
                    features: []
                };
                
                let processedZones = 0;
                const totalZones = Object.keys(zoneFeatures).length;
                
                for (const zone in zoneFeatures) {
                    log(`üèóÔ∏è Processing Zone ${zone}...`);
                    
                    try {
                        // Extract all points from all features in this zone
                        let allCoordinates = [];
                        zoneFeatures[zone].forEach(feature => {
                            const coords = turf.coordAll(feature);
                            allCoordinates = allCoordinates.concat(coords);
                        });
                        
                        if (allCoordinates.length < 3) {
                            log(`‚ö†Ô∏è Not enough coordinates for Zone ${zone}, skipping`);
                            continue;
                        }
                        
                        // Create a points feature collection
                        const points = turf.points(allCoordinates);
                        
                        // Create an outer boundary based on the selected method
                        let boundary;
                        
                        if (boundaryType === 'simple') {
                            // Simple boundary - create convex hull
                            boundary = turf.convex(points);
                        } else {
                            // Detailed boundary - create concave hull
                            boundary = turf.concave(points, { maxEdge: 20, units: 'kilometers' });
                            if (!boundary) {
                                // Fall back to convex hull if concave fails
                                boundary = turf.convex(points);
                            }
                        }
                        
                        // Simplify the boundary to reduce complexity
                        const simplified = turf.simplify(boundary, {
                            tolerance: simplifyLevel,
                            highQuality: true
                        });
                        
                        // Add buffer if specified
                        let finalBoundary = simplified;
                        if (bufferSize > 0) {
                            finalBoundary = turf.buffer(simplified, bufferSize, { units: 'kilometers' });
                        }
                        
                        // Add the boundary to the collection
                        zoneBoundaries.features.push({
                            type: 'Feature',
                            properties: {
                                zone: zone,
                                name: zoneInfo.zones[zone].name,
                                color: zoneInfo.zones[zone].color,
                                gebiet: zoneInfo.zones[zone].gebiet
                            },
                            geometry: finalBoundary.geometry
                        });
                    } catch (error) {
                        log(`‚ö†Ô∏è Error processing Zone ${zone}: ${error.message}`);
                    }
                    
                    // Update progress
                    processedZones++;
                    setProgress(65 + (processedZones / totalZones) * 35); // 65-100%
                }
                
                // Create final result
                boundaryLayers = {
                    gebietBoundaries: gebietBoundaries,
                    zoneBoundaries: zoneBoundaries
                };
                
                // Show output
                const output = document.getElementById('output');
                output.value = JSON.stringify(boundaryLayers, null, 2);
                
                // Enable download button
                document.getElementById('download').disabled = false;
                document.getElementById('generate').disabled = false;
                
                log("‚úÖ Boundary generation complete! Click 'Show Preview' to see the result.");
                
            } catch (error) {
                log(`‚ùå Error generating boundaries: ${error.message}`);
                document.getElementById('generate').disabled = false;
            }
        });
        
        // Download the generated GeoJSON
        document.getElementById('download').addEventListener('click', function() {
            const data = document.getElementById('output').value;
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'liefergebiet_boundaries.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log("üíæ Boundaries file downloaded");
        });
    </script>
</body>
</html>